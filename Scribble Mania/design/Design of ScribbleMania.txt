Design of ScribbleMania:


First of all, the architecture of the program is designed in two main parts in the most simplistic way. 

The first major part is the screen navigation. There are a lot of screens in the program and the way they all work nicely together is by defining the two major screens in two different classes. The reason I did this is that there are a lot of shared attributes that a screen and its subscreens share. Therefore, by making them class objects, it maximizes the code reusage. The first important screen we see right after we run the program is the splashScreen. Within the splashScreen class, there are Setting class that gives the users a short definition of the game and how to win the game, Download Class that showcase the levels user has previously solved on a certain machine and LevelSelect class that allows the player to select which level the user wants to play. Secondly, the most important screen the is gameMode screen. Where it's basically a canvas that allows user to draw shapes. From the main gameMode screen, user can go to the instuction page, going back to the level select screen, or, by solving the current level, entering the levelComplete screen. From the levelComplete screen, user can again choose to go to level select screen, replay the current level or to move on to the next level. This concludes the multi-screen design. Additionally, the program saves screenshots of solved level and also data including the time used to solve and shapes used to solve locally on user's computer for later retrieval.The Graphical User Interface (GUI) is designed in the way that is both visually pleasing and easy to navigate through. There are two main modes of the game. The first mode is to play the levels I designed. (More levels will be designed if more time is allowed) User has to finish certain task in order to pass. And the second mode of the game is the sandbox mode. In the sandbox mode, it gives the user flexibility to do anything with the game i.e. draw any shapes without any time constraint or shape constraints. And in the sandbox mode, user can be really creative and draw interesting shapes that will subject to real world physics. 

The second major part is the gameMode and most of the complex physics algorithms goes into the Enviornment class. At first glance it might seem obvious to include the code for importing, initialising and creating the Pygame screen: surely we'll always require it. But what if we later wants to display the particles using a different package, like PyOpenGL, or even create a command line display? Or what if you just want some code to tell you where a particle with a given position, mass and velocity will be in t units of time? More likely, what if you want to incorporate this code into a game in which you have already initialised and created a Pygame screen and now want to add the simulation to part of the screen. In general it's a good idea to separate code that determine the behaviour of your objects (the Model) from code that determines how your objects are displayed (the View); it makes changing either one independently of the other much simpler. This is part of the Model-View-Controller architecture, only we're not going to separate the Controller (i.e. the mouse input) for now. Within the Enviornment class, it describes a environment that has physics effects. We can put either particle or a user customized shape/curve into the enviornment and those shape objects will subject to the same physically effect under the enviornment. In the enviornment class is where all the physics happened. It defines the gravity, the mass of air, the acceleration index, speed of object, mass of object, elasticity of object, drag of the object. When the objects are being added to the enviornment, the env.update() will constantly making sure the object is doing the following: 1.move() 2.accelerate() 3.bounce() 4.collide(). Each algorithm has a lot of complexity in physics to it because it not only considers angle and speed but also mass and elasticity. Finally, what it comes down to is the Particle and Curve class. Particle is an object that has x,y radius and mass. Curve is a composite of list of particles. So that, again, the code and algorithm has a lot of reusability. Because a curve behaves similarily with a particle. 

Last but not least, the really cool part about the additional feature of the program is the Quadtree class. Quadtree is an algorithm that works as a tree that maps out the region when the target is within the range. The way it does it is by dividing the region into given number of rectangles. When the number of rectangles is big enough, it will become a pretty accurate collision checker for any irregular shapes. Quadtree class is originally something I want to adopt as a collision check, however, it turned into something that gives the player better visualized experience.

Programs I studied the most from is Brain it On! Because they used Unity, which is a professional game making module, their physics simulation effect is a lot better. My program, written in python pygame, can do most of the collision checks. However, if more time is give, the center of mass analysis and moments will be added to the algorithm to make the environment more analogous to real world physics. This is increase the level of difficulty by leaps and bounds but the game will be more intriguing to play.